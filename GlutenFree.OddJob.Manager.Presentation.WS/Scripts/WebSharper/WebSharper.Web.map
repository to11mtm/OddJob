{
"version": 3,
"sourceRoot": "Source",
"sources": ["WebSharper.Web/ClientSideJson.fs", "WebSharper.Web/Control.fs"],
"sourcesContent": ["// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2014 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nmodule internal WebSharper.ClientSideJson\n\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\n\ntype OptionalFieldKind =\n    /// The field doesn't have type option<'T>\n    | NotOption = 0\n    /// The field has type option<'T>\n    | NormalOption = 1\n    /// The field has type option<'T> and is marked [<OptionalField>]\n    | MarkedOption = 2\n    /// The field has type Optional<'T>\n    | ErasedOption = 3\n\nlet ServerSideProvider = WebSharper.Core.Json.Provider.Create ()\n\n[<JavaScript>]\nmodule Provider =\n    let Id () = \n        ()\n        fun () -> id\n\n    let EncodeTuple (encs: (unit -> obj -> obj)[]) : (unit -> obj[] -> obj) =\n        ()\n        fun () args ->\n            box (Array.map2 (fun f x -> f () x) encs args)\n\n    let EncodeDateTime () =\n        ()\n        fun () (x: System.DateTime) ->\n            box (x.JS.ToISOString())\n\n    let EncodeDateTimeOffset () =\n        ()\n        fun () (x: System.DateTimeOffset) ->\n            box (New [ \"d\" => x.DateTime.JS.ToISOString(); \"o\" => x?o ])\n\n    let EncodeList (encEl: unit -> 'T -> obj) : (unit -> list<'T> -> obj) =\n        ()\n        fun () (l: list<'T>) ->\n            let a : obj[] = [||]\n            let e = encEl()\n            l |> List.iter (fun x -> a.JS.Push (e x) |> ignore)\n            box a\n\n    let EncodeRecord (_: obj) (fields: (string * (unit -> obj -> obj) * OptionalFieldKind)[]) : (unit -> 'T -> obj) =\n        ()\n        fun () x ->\n            let o = New []\n            fields |> Array.iter (fun (name, enc, kind) ->\n                match kind with\n                | OptionalFieldKind.NotOption ->\n                    o?(name) <- enc () x?(name)\n                | OptionalFieldKind.NormalOption ->\n                    match x?(name) with\n                    | Some x -> o?(name) <- enc () x\n                    | None -> ()\n                | OptionalFieldKind.MarkedOption ->\n                    if JS.HasOwnProperty x name then\n                        o?(name) <- enc () x?(name)\n                | OptionalFieldKind.ErasedOption ->\n                    if x?(name) ===. JS.Undefined then\n                        o?(name) <- enc () x?(name)\n                | _ -> failwith \"Invalid field option kind\")\n            o\n\n    let EncodeUnion (_: obj) (discr: string) (cases: (string * (string * string * (unit -> obj -> obj) * OptionalFieldKind)[])[]) : (unit -> 'T -> obj) =\n        ()\n        fun () x ->\n            if JS.TypeOf x ===. JS.Object && x !=. null then\n                let o = New []\n                let tag = x?(\"$\")\n                let tagName, fields = cases.[tag]\n                if JS.TypeOf discr = JS.Kind.String then o?(discr) <- tagName\n                fields |> Array.iter (fun (from, ``to``, enc, kind) ->\n                    match from with\n                    | null -> // inline record\n                        let record = enc () (x?(\"$0\"))\n                        JS.ForEach record (fun f -> o?(f) <- record?(f); false)\n                    | from -> // normal args\n                        match kind with\n                        | OptionalFieldKind.NotOption ->\n                            o?(``to``) <- enc () (x?(from))\n                        | OptionalFieldKind.NormalOption ->\n                            match x?(from) with\n                            | Some x -> o?(``to``) <- enc () x\n                            | None -> ()\n                        | _ -> failwith \"Invalid field option kind\")\n                o\n            else box x // [<Constant>]\n\n    let EncodeArray (encEl: (unit -> 'T -> obj)) : (unit -> 'T[] -> obj) =\n        ()\n        fun () (a: 'T[]) ->\n            let e = encEl()\n            box (Array.map e a)\n\n    let EncodeSet (encEl: (unit -> 'T -> obj)) : (unit -> Set<'T> -> obj) =\n        ()\n        fun () (s: Set<'T>) ->\n            let a : obj[] = [||]\n            let e = encEl()\n            s |> Set.iter (fun x -> a.JS.Push (e x) |> ignore)\n            box a\n\n    let EncodeStringMap (encEl:(unit -> 'T -> obj)) : (unit -> Map<string, 'T> -> obj) =\n        ()\n        fun () (m: Map<string, 'T>) ->\n            let o = New []\n            let e = encEl()\n            m |> Map.iter (fun k v -> o?(k) <- e v)\n            o\n\n    let EncodeArrayMap (encKey:(unit -> 'K -> obj)) (encEl:(unit -> 'V -> obj)) : (unit -> Map<'K, 'V> -> obj) =\n        ()\n        fun () (m: Map<'K, 'V>) ->\n            let a : obj[][] = [||]\n            let k = encKey()\n            let e = encEl()\n            m |> Map.iter (fun key el -> a.JS.Push([| [| k key; e el |] |]) |> ignore)\n            box a\n\n    let EncodeStringDictionary (encEl:(unit -> 'T -> obj)) : (unit -> Dictionary<string, 'T> -> obj) =\n        ()\n        fun () (d: Dictionary<string, 'T>) ->\n            let o = New []\n            let e = encEl()\n            for KeyValue(k, v) in d :> seq<_> do o?(k) <- e v\n            o\n\n    let EncodeArrayDictionary (encKey: (unit -> 'K -> obj)) (encEl: (unit -> 'V -> obj)) : (unit -> Dictionary<'K, 'V> -> obj) =\n        ()\n        fun () (d: Dictionary<'K, 'V>) ->\n            let a : obj[][] = [||]\n            let k = encKey()\n            let e = encEl()\n            for KeyValue(key, el) in d do a.JS.Push([| [| k key; e el |] |]) |> ignore\n            box a\n\n    let EncodeLinkedList (encEl:(unit -> 'T -> obj)) : (unit -> LinkedList<'T> -> obj) =\n        ()\n        fun () (d: LinkedList<'T>) ->\n            let o = Array<'T>()\n            let e = encEl()\n            for x in d :> seq<'T> do o.Push(e x) |> ignore\n            box o\n\n    let DecodeTuple (decs: (unit -> obj -> obj)[]) : (unit -> obj -> obj[]) =\n        As (EncodeTuple decs)\n\n    let DecodeDateTime() =\n        ()\n        fun () (x: obj) ->\n            if JS.HasOwnProperty x \"d\" then\n                Date(x?d: string).Self\n            else \n                Date(x :?> string).Self\n\n    let DecodeDateTimeOffset() =\n        ()\n        fun () (x: obj) ->\n            if JS.HasOwnProperty x \"d\" then\n                System.DateTimeOffset(Date(x?d: string).Self, System.TimeSpan.FromMinutes x?o)\n            else \n                System.DateTimeOffset(Date(x :?> string).Self, System.TimeSpan.Zero)\n\n    let DecodeList (decEl: (unit -> obj -> 'T)) : (unit -> obj -> list<'T>) =\n        ()\n        fun () (a : obj) ->\n            let e = decEl()\n            List.init (a :?> obj[]).Length (fun i -> e (a :?> obj[]).[i])\n\n    let DecodeSet (decEl: unit -> obj -> 'T) : (unit -> obj -> Set<'T>) =\n        ()\n        fun () (a : obj) ->\n            let e = decEl()\n            Set.ofArray(Array.map e (a :?> obj[]))\n\n    let DecodeRecord (t: obj) (fields: (string * (unit -> obj -> obj) * OptionalFieldKind)[]) : (unit -> obj -> 'T) =\n        ()\n        fun () (x: obj) ->\n            let o = if t ===. JS.Undefined then New [] else JS.New t\n            fields |> Array.iter (fun (name, dec, kind) ->\n                match kind with\n                | OptionalFieldKind.NotOption ->\n                    if JS.HasOwnProperty x name then\n                        o?(name) <- dec () x?(name)\n                    else failwith (\"Missing mandatory field: \" + name)\n                | OptionalFieldKind.NormalOption ->\n                    o?(name) <-\n                        if JS.HasOwnProperty x name\n                        then Some (dec () x?(name))\n                        else None\n                | OptionalFieldKind.MarkedOption ->\n                    if JS.HasOwnProperty x name then\n                        o?(name) <- (dec () x?(name))\n                | OptionalFieldKind.ErasedOption ->\n                    if x?(name) ===. JS.Undefined then\n                        o?(name) <- (dec () x?(name))\n                | _ -> failwith \"Invalid field option kind\")\n            o\n\n    let DecodeUnion (t: obj) (discr: string) (cases: (string * (string * string * (unit -> obj -> obj) * OptionalFieldKind)[])[]) : (unit -> obj -> 'T) =\n        ()\n        fun () (x: obj) ->\n            if JS.TypeOf x ===. JS.Object && x !=. null then\n                let o = if t ===. JS.Undefined then New [] else JS.New t\n                let tag =\n                    // [<NamedUnionCases(discr)>]\n                    if JS.TypeOf discr = JS.Kind.String then\n                        let tagName = x?(discr)\n                        cases |> Array.findIndex (fun (name, _) -> name = tagName)\n                    else // [<NamedUnionCases>]\n                        let r = ref JS.Undefined\n                        JS.ForEach discr (fun k ->\n                            if JS.HasOwnProperty x k then r := discr?(k); true else false)\n                        !r\n                o?(\"$\") <- tag\n                cases.[tag] |> snd |> Array.iter (fun (from, ``to``, dec, kind) ->\n                    match from with\n                    | null -> // inline record\n                        let r = dec () x\n                        // eliminate tag field if record deserializer is identity\n                        if As<bool> ``to`` then \n                            JS.Delete r discr\n                        o?(\"$0\") <- r\n                    | from -> // normal args\n                        match kind with\n                        | OptionalFieldKind.NotOption ->\n                            o?(from) <- dec () (x?(``to``))\n                        | OptionalFieldKind.NormalOption ->\n                            o?(from) <-\n                                if JS.HasOwnProperty x ``to``\n                                then Some (dec () x?(``to``))\n                                else None\n                        | _ -> failwith \"Invalid field option kind\")\n                o\n            else x :?> 'T // [<Constant>]\n\n    let DecodeArray (decEl :(unit -> obj -> 'T)) : (unit -> obj -> 'T[]) =\n        As (EncodeArray (As decEl))\n\n    let DecodeStringMap (decEl :(unit -> obj -> 'T)) : (unit -> obj -> Map<string, 'T>) =\n        ()\n        fun () (o: obj) ->\n            let m = ref Map.empty\n            let decEl = decEl ()\n            JS.ForEach o (fun k -> m := Map.add k (decEl o?(k)) !m; false)\n            !m\n\n    let DecodeArrayMap (decKey :(unit -> obj -> 'K)) (decEl :(unit -> obj -> 'V)) : (unit -> obj -> Map<'K, 'V>) =\n        ()\n        fun () (o: obj) ->\n            let decKey = decKey()\n            let decEl = decEl()\n            let mutable m = Map<'K, 'V> []\n            for k, v in o :?> (obj * obj)[] do m <- Map.add (decKey k) (decEl v) m\n            m\n\n    let DecodeStringDictionary (decEl: unit -> obj -> 'T) : (unit -> obj -> Dictionary<string, 'T>) =\n        ()\n        fun () (o: obj) ->\n            let d = System.Collections.Generic.Dictionary()\n            let decEl = decEl ()\n            JS.ForEach o (fun k -> d.Add(k, decEl o?(k)); false)\n            d\n\n    let DecodeArrayDictionary (decKey :(unit -> obj -> 'K)) (decEl :(unit -> obj -> 'V)) : (unit -> obj -> Dictionary<'K, 'V>) =\n        ()\n        fun () (o: obj) ->\n            let decKey = decKey()\n            let decEl = decEl()\n            let d = Dictionary<'K, 'V>()\n            for k, v in o :?> (obj * obj)[] do d.Add(decKey k, decEl v)\n            d\n\n    let DecodeLinkedList (decEl: unit -> obj -> 'T) : (unit -> obj -> LinkedList<'T>) =\n        ()\n        fun () (o: obj) ->\n            let l = LinkedList<'T>()\n            let decEl = decEl()\n            for x in o :?> obj[] do l.AddLast(decEl x) |> ignore\n            l\n\nmodule Macro =\n\n    module M = WebSharper.Core.Metadata\n    open WebSharper.Core.AST\n    module JI = WebSharper.Core.Json.Internal\n    type private BF = System.Reflection.BindingFlags\n\n    type Parameters =\n        {\n            Warnings : ResizeArray<string>\n            Dependencies : ResizeArray<M.Node>\n            Compilation : M.ICompilation\n        }\n\n    [<AutoOpen>]\n    module private Internals =\n\n        let cString s = !~ (Literal.String s)\n        let inline cInt i = !~ (Int i)\n\n        let mainJsonModule =\n            TypeDefinition {\n                FullName = \"WebSharper.Json\"\n                Assembly = \"WebSharper.Main\"\n            }\n        let mJson (comp: M.ICompilation) f args =\n            let m = comp.GetClassInfo(mainJsonModule).Value.Methods.Keys |> Seq.find (fun m -> m.Value.MethodName = f)\n            Call(None, NonGeneric mainJsonModule, NonGeneric m, args)\n\n        let (|T|) (t: TypeDefinition) = t.Value.FullName\n        let (|C|_|) (t: Type) =\n            match t with \n            | ConcreteType { Entity = e; Generics = g} -> Some (e, g)\n            | _ -> None\n\n        let providerType = \n            TypeDefinition {\n                FullName = \"WebSharper.ClientSideJson+Provider\"\n                Assembly = \"WebSharper.Web\"\n            }\n        let invoke (comp: M.ICompilation) isEnc n args = \n            let f = (if isEnc then \"Encode\" else \"Decode\") + n\n            let m = comp.GetClassInfo(providerType).Value.Methods.Keys |> Seq.find (fun m -> m.Value.MethodName = f)\n            Call(None, NonGeneric providerType, NonGeneric m, args)\n        let invokeId (comp: M.ICompilation) = \n            let m = comp.GetClassInfo(providerType).Value.Methods.Keys |> Seq.find (fun m -> m.Value.MethodName = \"Id\")\n            Call(None, NonGeneric providerType, NonGeneric m, [])\n\n        type EncodeResult = Choice<Expression, string, Type>\n\n        let (>>=) (x: EncodeResult) (f: Expression -> EncodeResult) =\n            match x with\n            | Choice1Of3 e -> f e\n            | _ -> x\n        let ok x = Choice1Of3 x : EncodeResult\n        let fail x = Choice2Of3 x : EncodeResult\n        let generic t = Choice3Of3 t : EncodeResult\n\n        let mapOk f x =\n            match x with\n            | Choice1Of3 x -> Choice1Of3 (f x) \n            | _ -> x\n\n        /// Returns None if MacroNeedsResolvedTypeArg.\n        let getEncoding name isEnc param (t: Type) : EncodeResult =\n            let warn msg = param.Warnings.Add msg\n            let addTypeDep td = param.Dependencies.Add (M.TypeNode td)\n            let comp = param.Compilation\n            let call = invoke comp isEnc\n            let ident = invokeId comp \n            let isIdent r =\n                match r with \n                | Choice1Of3 e when obj.ReferenceEquals(e, ident) -> true\n                | _ -> false\n            let rec encode t =\n                match t with\n                | ArrayType (t, 1)\n                | C (T \"System.Collections.Generic.List`1\", [t])\n                | C (T \"System.Collections.Generic.Queue`1\", [t])\n                | C (T \"System.Collections.Generic.Stack`1\", [t]) ->\n                    encode t >>= fun e ->\n                    ok (call \"Array\" [e])\n                | ArrayType _ ->\n                    fail \"JSON serialization for multidimensional arrays is not supported.\"\n                | VoidType\n                | C (T (\"Microsoft.FSharp.Core.Unit\"\n                            | \"System.Boolean\"\n                            | \"System.SByte\"   | \"System.Byte\"\n                            | \"System.Int16\"   | \"System.UInt16\"\n                            | \"System.Int32\"   | \"System.UInt32\"\n                            | \"System.Int64\"   | \"System.UInt64\"\n                            | \"System.Single\"  | \"System.Double\"\n                            | \"System.String\"  | \"System.Guid\"\n                            | \"WebSharper.Core.Json+Encoded\"), []) ->\n                    ok ident\n                | C (T \"System.Object\", []) ->\n                    if isEnc then \n                        fail \"JSON serialization for System.Object is not supported; only deserialization.\" \n                    else ok ident\n                | C (T \"Microsoft.FSharp.Collections.FSharpList`1\", [t]) ->\n                    encode t >>= fun e ->\n                    ok (call \"List\" [e])\n                | C (T \"Microsoft.FSharp.Collections.FSharpSet`1\", [t]) ->\n                    encode t >>= fun e ->\n                    ok (call \"Set\" [e])\n                | C (T \"Microsoft.FSharp.Collections.FSharpMap`2\", [k; t]) ->\n                    match k with\n                    | C (T \"System.String\", []) ->\n                        encode t >>= fun e -> \n                        ok (call \"StringMap\" [e])\n                    | _ ->\n                        encode k >>= fun k -> \n                        encode t >>= fun e -> \n                        ok (call \"ArrayMap\" [k; e])\n                | C (T \"System.Collections.Generic.Dictionary`2\", [k; t]) ->\n                    match k with\n                    | C (T \"System.String\", []) ->\n                        encode t >>= fun e ->\n                        ok (call \"StringDictionary\" [e])\n                    | _ ->\n                        encode k >>= fun k ->\n                        encode t >>= fun e ->\n                        ok (call \"ArrayDictionary\" [k; e])\n                | C (T \"System.Collections.Generic.LinkedList`1\", [t]) ->\n                    encode t >>= fun e ->\n                    ok (call \"LinkedList\" [e])\n                | TupleType (ts, _) ->\n                    ((fun es -> ok (call \"Tuple\" [NewArray es])), ts)\n                    ||> List.fold (fun k t ->\n                        fun es -> encode t >>= fun e -> k (e :: es))\n                    <| []\n                | C (T \"System.DateTime\", []) ->\n                    ok (call \"DateTime\" [])\n                | C (T \"System.DateTimeOffset\", []) ->\n                    ok (call \"DateTimeOffset\" [])\n                | C (td, args) ->                    \n                    let top = comp.AssemblyName.Replace(\".\",\"$\") + if isEnc then \"_JsonEncoder\" else \"_JsonDecoder\"\n                    let key = M.CompositeEntry [ M.StringEntry top; M.TypeEntry t ]\n                    match comp.GetMetadataEntries key with                    \n                    | M.StringEntry \"id\" :: _ ->\n                        ok ident\n                    | M.CompositeEntry [ M.TypeDefinitionEntry gtd; M.MethodEntry gm ] :: _ ->\n                        Lambda([], Call(None, NonGeneric gtd, NonGeneric gm, [])) |> ok\n                    | _ ->\n                        let gtd, gm, _ = comp.NewGenerated([top; \"j\"])\n                        let _, gv, va = comp.NewGenerated([top; \"_\" + \"v\"])\n                        comp.AddGeneratedCode(gv, Undefined)\n                        comp.AddMetadataEntry(key, M.CompositeEntry [ M.TypeDefinitionEntry gtd; M.MethodEntry gm ])\n                        ((fun es ->\n                            let enc = encRecType t args es\n                            if isIdent enc then\n                                comp.AddMetadataEntry(key, M.StringEntry \"id\")\n                                comp.AddGeneratedInline(gm, ident)\n                                enc\n                            else\n                                enc >>= fun e ->\n                                let v = Lambda([], Call (None, NonGeneric gtd, NonGeneric gv, []))\n                                let vn = Value (String va.Value.Head)\n                                let b = Lambda ([], Conditional(v, v, ItemSet(Global [top], vn, Application(e, [], NonPure, Some 0))))\n                                comp.AddGeneratedCode(gm, b)\n                                Lambda([], Call(None, NonGeneric gtd, NonGeneric gm, [])) |> ok\n                         ), args)\n                        ||> List.fold (fun k t es ->\n                            encode t >>= fun e -> k ((t, e) :: es))\n                        <| []\n                | ConcreteType _ -> failwith \"impossible\"\n                | FSharpFuncType _ -> \n                    fail (name + \": Cannot de/serialize a function value.\")\n                | ByRefType _ ->\n                    fail (name + \": Cannot de/serialize a byref value.\")\n                | LocalTypeParameter\n                | StaticTypeParameter _ \n                | TypeParameter _ ->\n                    generic t\n            // Encode a type that might be recursively defined\n            and encRecType t targs args =\n                let td = t.TypeDefinition\n                match comp.GetCustomTypeInfo td with\n                | M.EnumInfo _ -> ok ident\n                | M.FSharpRecordInfo fields ->\n                    let fieldEncoders =\n                        fields\n                        |> List.map (fun f ->\n                            if Option.isSome f.DateTimeFormat then\n                                warn (sprintf \"Warning: This record field has a custom DateTime format: %s.%s. \\\n                                    Client-side JSON serialization does not support custom DateTime formatting. \\\n                                    This field will be serialized using ISO format.\"\n                                    f.RecordFieldType.TypeDefinition.Value.FullName f.Name)\n                            let t, optionKind =\n                                match f.RecordFieldType with\n                                | ConcreteType { Entity = d; Generics = [p] } when d.Value.FullName = \"Microsoft.FSharp.Core.FSharpOption`1\" ->\n                                    if f.Optional then p, OptionalFieldKind.MarkedOption\n                                    else p, OptionalFieldKind.NormalOption\n                                | ConcreteType { Entity = d; Generics = [p] } when d.Value.FullName = \"WebSharper.JavaScript.Optional`1\" ->\n                                    p, OptionalFieldKind.ErasedOption\n                                | t ->    \n                                    t, OptionalFieldKind.NotOption\n                            f.JSName, optionKind, encode (t.SubstituteGenerics (Array.ofList targs))\n                        )  \n                    let pr =\n                        match comp.GetClassInfo td with\n                        | Some cls -> \n                            addTypeDep td \n                            if cls.HasWSPrototype then\n                                GlobalAccess cls.Address.Value\n                            else Undefined\n                        | _ -> Undefined\n                    if pr = Undefined && fieldEncoders |> List.forall (fun (_, fo, fe) ->\n                        fo <> OptionalFieldKind.NormalOption && isIdent fe\n                    )\n                    then ok ident\n                    else\n                        ((fun es ->\n                            let es, tts = List.unzip es\n                            ok (call \"Record\" [pr; NewArray es])\n                            ), fieldEncoders)\n                        ||> List.fold (fun k (fn, fo, fe) es ->                     \n                                fe >>= fun e ->\n                                k ((NewArray [cString fn; e; cInt (int fo)], t) :: es))\n                        <| []\n                // TODO: handle nested case type (possible when using from C#)\n                | M.FSharpUnionInfo u ->\n                    let tryGetInlinableRecordInfo (uci: M.FSharpUnionCaseInfo) =\n                        match uci.Kind with \n                        | M.NormalFSharpUnionCase [f] when f.Name = \"Item\" ->\n                            let rec inl uft =\n                                match uft with\n                                | ConcreteType { Entity = fTd } as ft ->\n                                    match comp.GetCustomTypeInfo fTd with\n                                    | M.FSharpRecordInfo fRec -> Some (ft, fRec)\n                                    | _ -> None\n                                | TypeParameter i -> inl (targs.[i])\n                                | _ -> None\n                            inl f.UnionFieldType\n                        | _ -> None\n                    let isOption (t: Type) =\n                        match t with\n                        | ConcreteType { Entity = e } ->\n                            e.Value.FullName = \"Microsoft.FSharp.Core.FSharpOption`1\"\n                        | _ -> false\n                    let discr =\n                        match u.NamedUnionCases with\n                        | None -> JI.StandardField\n                        | Some None -> \n                            let allCases =\n                                u.Cases |> Seq.mapi (fun i uci ->\n                                    i,\n                                    match tryGetInlinableRecordInfo uci with\n                                    | Some (_, fRec) ->\n                                        fRec |> Seq.filter (fun rf -> not (isOption rf.RecordFieldType))\n                                        |> Seq.map (fun rf -> rf.JSName) |> Set.ofSeq\n                                    | None ->\n                                        match uci.Kind with \n                                        | M.NormalFSharpUnionCase fs ->\n                                            fs\n                                            |> List.choose (fun f ->\n                                                if isOption f.UnionFieldType then None else Some f.Name)\n                                            |> Set.ofList\n                                        | _ -> Set.empty\n                                )\n                                |> Map.ofSeq\n                            let findDistinguishingCase (cases: Map<int, Set<string>>) =\n                                cases\n                                |> Map.tryPick (fun t fs ->\n                                    let allOtherFields =\n                                        allCases\n                                        |> Seq.choose (fun (KeyValue(t', fs)) ->\n                                            if t = t' then None else Some fs)\n                                        |> Set.unionMany\n                                    let uniqueCases = fs - allOtherFields\n                                    if Set.isEmpty uniqueCases then\n                                        None\n                                    else Some (Seq.head uniqueCases, t)\n                                )\n                            let rec buildTable acc cases =\n                                if Map.isEmpty cases then acc else\n                                match findDistinguishingCase cases with\n                                | None -> failwithf \"No decoder for %s\" t.AssemblyQualifiedName\n                                | Some (name, tag) ->\n                                    buildTable\n                                        <| (name, tag) :: acc\n                                        <| Map.remove tag cases\n                            buildTable [] allCases |> JI.NoField\n                        | Some (Some n) -> JI.NamedField n\n                    let cases = u.Cases\n                    ((0, fun cases ->\n                        let cases = NewArray cases\n                        let discr =\n                            match discr with\n                            | JI.NoField discrFields ->\n                                discrFields\n                                |> List.map (fun (name, id) -> name, cInt id)\n                                |> Object\n                            | JI.StandardField -> cString \"$\"\n                            | JI.NamedField n -> cString n\n                        let tn =\n                            match comp.GetClassInfo td with\n                            | Some cls -> \n                                addTypeDep td\n                                if cls.HasWSPrototype then\n                                    GlobalAccess cls.Address.Value\n                                else\n                                    Undefined\n                            | _ -> Undefined\n                        ok (call \"Union\" [tn; discr; cases])\n                        ), cases)\n                    ||> List.fold (fun (i, k) case ->\n                        i + 1, fun es ->\n                            match tryGetInlinableRecordInfo case with\n                            | Some (ft, _) -> \n                                let tag =\n                                    match discr with\n                                    | JI.StandardField -> cInt i\n                                    | _ -> cString (match case.JsonName with Some n -> n | _ -> case.Name)\n                                let encF = encode ft \n                                let elimTag =\n                                    if isIdent encF then !~(Bool true) else !~Null\n                                encF >>= fun e ->\n                                k (NewArray [tag; NewArray [NewArray [!~Null; elimTag; e]]] :: es)\n                            | _ ->\n                            match case.Kind with\n                            | M.NormalFSharpUnionCase fields ->\n                                ((0, fun argNames ->\n                                    let tag =\n                                        match u.NamedUnionCases with\n                                        | None -> cInt i\n                                        | _ -> cString (match case.JsonName with Some n -> n | _ -> case.Name)\n                                    k (NewArray [tag; NewArray argNames] :: es)\n                                    ), fields)\n                                ||> List.fold (fun (j, k) f -> //(argName, argT, argFlags) ->\n                                    if Option.isSome f.DateTimeFormat then\n                                        warn (sprintf \"Warning: This union case field has a custom DateTime format: %s.%s [%s]. \\\n                                            Client-side JSON serialization does not support custom DateTime formatting. \\\n                                            This field will be serialized using ISO format.\"\n                                            f.UnionFieldType.TypeDefinition.Value.FullName case.Name f.Name)\n                                    let argT, optionKind =\n                                        match f.UnionFieldType with\n                                        | ConcreteType { Entity = d; Generics = [p] } when d.Value.FullName = \"Microsoft.FSharp.Core.FSharpOption`1\" ->\n                                            p, cInt (int OptionalFieldKind.NormalOption)\n                                        | t ->    \n                                            t, cInt (int OptionalFieldKind.NotOption)\n                                    j + 1, fun es ->\n                                        encode (argT.SubstituteGenerics (Array.ofList targs)) >>= fun e ->\n                                        k (NewArray [cString (\"$\" + string j); cString f.Name; e; optionKind] :: es))\n                                |> snd\n                                <| []\n                            | M.SingletonFSharpUnionCase ->\n                                let tag =\n                                    match u.NamedUnionCases with\n                                    | None -> cInt i\n                                    | _ -> cString (match case.JsonName with Some n -> n | _ -> case.Name)\n                                k (NewArray [tag; NewArray []] :: es)\n                            | M.ConstantFSharpUnionCase _ -> k (!~Null :: es)\n                    )\n                    |> snd\n                    <| []\n                | _ -> \n                    match comp.GetClassInfo td with\n                    | Some cls ->\n                        let fieldEncoders =\n                            cls.Fields.Values\n                            |> Seq.choose (fun (f, _, ft) ->\n                                let jsNameTypeAndOption =\n                                    let isOption name isMarked =\n                                        match ft with\n                                        | ConcreteType { Entity = d; Generics = [p] } when d.Value.FullName = \"Microsoft.FSharp.Core.FSharpOption`1\" ->\n                                            if isMarked then\n                                                Some (name, p, OptionalFieldKind.MarkedOption) \n                                            else\n                                                Some (name, p, OptionalFieldKind.NormalOption) \n                                        | ConcreteType { Entity = d; Generics = [p] } when d.Value.FullName = \"WebSharper.JavaScript.Optional`1\" ->\n                                            Some (name, p, OptionalFieldKind.ErasedOption) \n                                        | ft ->    \n                                            Some (name, ft, OptionalFieldKind.NotOption)\n                                    match f with\n                                    | M.InstanceField n -> isOption n false\n                                    | M.IndexedField i -> isOption (string i) false\n                                    | M.OptionalField n -> isOption n true\n                                    | M.StaticField _ -> None\n                                jsNameTypeAndOption |> Option.map (fun (jsName, t, optionKind) ->\n                                    jsName, optionKind, encode (t.SubstituteGenerics (Array.ofList targs))\n                                )\n                            ) |> List.ofSeq\n                        let pr =\n                            match comp.GetClassInfo td with\n                            | Some cls -> \n                                addTypeDep td \n                                if cls.HasWSPrototype then\n                                    GlobalAccess cls.Address.Value\n                                else Undefined\n                            | _ -> Undefined\n                        if pr = Undefined && fieldEncoders |> List.forall (fun (_, fo, fe) ->\n                            fo <> OptionalFieldKind.NormalOption && isIdent fe\n                        )\n                        then ok ident\n                        else\n                            ((fun es ->\n                                let es, tts = List.unzip es\n                                ok (call \"Record\" [pr; NewArray es])\n                                ), fieldEncoders)\n                            ||> List.fold (fun k (fn, fo, fe) es ->                     \n                                    fe >>= fun e ->\n                                    k ((NewArray [cString fn; e; cInt (int fo)], t) :: es))\n                            <| []\n                    | _ ->\n                        fail (name + \": Type not supported: \" + t.TypeDefinition.Value.FullName)\n            encode t\n\n        let encodeLambda name param t =\n            getEncoding name true param t\n            |> mapOk (fun x -> Application(x, [], Pure, Some 0))\n\n        let encode name param t arg =\n            encodeLambda name param t\n            |> mapOk (fun x -> Application(x, [arg], Pure, Some 1))\n\n        let decodeLambda name param t =\n            getEncoding name false param t\n            |> mapOk (fun x -> Application(x, [], Pure, Some 0))\n\n        let decode name param t arg =\n            decodeLambda name param t\n            |> mapOk (fun x -> Application(x, [arg], Pure, Some 1))\n\n    let Encode param t arg =\n        // ENCODE()(arg)\n        encode \"Encode\" param t arg\n\n    let EncodeLambda warn t =\n        // ENCODE()\n        encodeLambda \"EncodeLambda\" warn t\n\n    let Serialize param t arg =\n        // JSON.stringify(ENCODE()(arg))\n        encode \"Serialize\" param t arg\n        |> mapOk (fun x -> mJson param.Compilation \"Stringify\" [x])\n\n    let SerializeLambda param t =\n        encodeLambda \"SerializeLambda\" param t\n        |> mapOk (fun x ->\n            let enc = Id.New(mut = false)\n            let arg = Id.New(mut = false)\n            // let enc = ENCODE() in fun arg -> JSON.stringify(enc(arg))\n            Let(enc, x,\n                Lambda([arg],\n                    mJson param.Compilation \"Stringify\" [Application(Var enc, [Var arg], Pure, Some 1)])))\n\n    let Decode param t arg =\n        // DECODE()(arg)\n        decode \"Decode\" param t arg\n\n    let DecodeLambda param t =\n        // DECODE()\n        decodeLambda \"DecodeLambda\" param t\n\n    let Deserialize param t arg =\n        // DECODE()(JSON.parse(arg))\n        decode \"Deserialize\" param t (mJson param.Compilation \"Parse\" [arg])\n\n    let DeserializeLambda param t =\n        decodeLambda \"DeserializeLambda\" param t\n        |> mapOk (fun x ->\n            let dec = Id.New(mut = false)\n            let arg = Id.New(mut = false)\n            // let dec = DECODE() in fun arg -> dec(JSON.parse(arg))\n            Let(dec, x,\n                Lambda([arg],\n                    Application(Var dec, [mJson param.Compilation \"Parse\" [Var arg]], Pure, Some 1))))\n\n    type SerializeMacro() =\n        inherit WebSharper.Core.Macro()\n\n        static let rec last = function\n            | [x] -> x\n            | x :: l -> last l\n            | _ -> failwith \"\"\n\n        override this.TranslateCall(c) =\n            let f =\n                match c.Method.Entity.Value.MethodName with\n                | \"Encode\" -> Encode\n                | \"Decode\" -> Decode\n                | \"Serialize\" -> Serialize\n                | \"Deserialize\" -> Deserialize\n                | _ -> failwith \"Invalid macro invocation\"\n            let param = \n                {\n                    Compilation = c.Compilation\n                    Warnings = ResizeArray()\n                    Dependencies = ResizeArray()\n                }\n            let res =\n                match f param c.Method.Generics.Head (last c.Arguments) with\n                | Choice1Of3 x -> WebSharper.Core.MacroOk x\n                | Choice2Of3 e -> WebSharper.Core.MacroError e\n                | Choice3Of3 t -> WebSharper.Core.MacroNeedsResolvedTypeArg t\n            let resWithWarnings =\n                if param.Warnings.Count > 0 then\n                    param.Warnings |> Seq.fold (fun res msg -> \n                        WebSharper.Core.MacroWarning (msg, res)) res\n                else res\n            if param.Dependencies.Count > 0 then\n                WebSharper.Core.MacroDependencies (List.ofSeq param.Dependencies, resWithWarnings)\n            else resWithWarnings    \n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2018 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.Web\n\nopen WebSharper\nopen WebSharper.Core\n\nmodule M = WebSharper.Core.Metadata\nmodule R = WebSharper.Core.AST.Reflection\n\n/// A server-side control that adds a runtime dependency on a given resource.\ntype Require (t: System.Type, [<System.ParamArray>] parameters: obj[]) =\n#if NET461 // ASP.NET: Control\n    inherit System.Web.UI.Control()\n#endif\n\n    let t = AST.Reflection.ReadTypeDefinition t\n    let req = \n        [M.ResourceNode (t, \n            if parameters.Length = 0 then None else Some(M.ParameterObject.OfObj parameters))]\n\n    interface INode with\n        member this.Write(_, _) = ()\n        member this.IsAttribute = false\n\n    interface IRequiresResources with\n        member this.Encode(_, _) = []\n        member this.Requires(_) = req :> _\n\n#if NET461 // ASP.NET: Control\n    override this.OnLoad _ =\n        this.ID <-\n            ScriptManager.Find(base.Page)\n                .Register(None, this, Shared.Metadata, Shared.Json)\n\n    override this.Render _ = ()\n#endif\n\n/// A server-side control that adds a runtime dependency on a given resource.\ntype Require<'T when 'T :> Resources.IResource>() =\n    inherit Require(typeof<'T>)\n\n/// A base class for defining custom ASP.NET controls. Inherit from this class,\n/// override the Body property and use the new class as a Server ASP.NET\n/// control in your application.\n[<AbstractClass>]\ntype Control() =\n#if NET461 // ASP.NET: Control\n    inherit System.Web.UI.Control()\n#endif\n\n    static let gen = System.Random()\n    [<System.NonSerialized>]\n    let mutable id = System.String.Format(\"ws{0:x}\", gen.Next().ToString())\n\n#if NET461 // ASP.NET: Control\n    override this.ID\n#else\n    member this.ID\n#endif\n        with get () = id\n        and set x = id <- x\n\n#if NET461 // ASP.NET: Control\n    override this.OnLoad _ =\n        this.ID <-\n            ScriptManager.Find(base.Page)\n                .Register(Some id, this, Shared.Metadata, Shared.Json)\n#endif\n\n    interface INode with\n        member this.IsAttribute = false\n        member this.Write (_, w) =\n            w.Write(\"\"\"<div id=\"{0}\"></div>\"\"\", this.ID)\n\n    [<JavaScript>]\n    abstract member Body : IControlBody\n\n    interface IControl with\n        [<JavaScript>]\n        member this.Body = this.Body\n        member this.Id = this.ID\n\n    member this.GetBodyNode() =\n        let t = this.GetType()\n        let t = if t.IsGenericType then t.GetGenericTypeDefinition() else t\n        let m = t.GetProperty(\"Body\").GetGetMethod()\n        M.MethodNode (R.ReadTypeDefinition t, R.ReadMethod m)\n\n    interface IRequiresResources with\n        member this.Requires(_) =\n            this.GetBodyNode() |> Seq.singleton\n\n        member this.Encode(meta, json) =\n            [this.ID, json.GetEncoder(this.GetType()).Encode this]\n\n#if NET461 // ASP.NET: Control\n    override this.Render writer =\n#else\n    member this.Render (writer: WebSharper.Core.Resources.HtmlTextWriter) =\n#endif\n        writer.WriteLine(\"<div id='{0}'></div>\", this.ID)\n\nopen WebSharper.JavaScript\nopen Microsoft.FSharp.Quotations\nopen Microsoft.FSharp.Quotations.Patterns\n\nmodule ClientSideInternals =\n\n    module M = WebSharper.Core.Metadata\n    module R = WebSharper.Core.AST.Reflection\n    module J = WebSharper.Core.Json\n    module P = FSharp.Quotations.Patterns\n\n    let getLocation' (q: Expr) =\n        let (|Val|_|) e : 't option =\n            match e with\n            | Quotations.Patterns.Value(:? 't as v,_) -> Some v\n            | _ -> None\n        let l =\n            q.CustomAttributes |> Seq.tryPick (function\n                | NewTuple [ Val \"DebugRange\";\n                             NewTuple [ Val (file: string)\n                                        Val (startLine: int)\n                                        Val (startCol: int)\n                                        Val (endLine: int)\n                                        Val (endCol: int) ] ] ->\n                    Some (sprintf \"%s: %i.%i-%i.%i\" file startLine startCol endLine endCol)\n                | _ -> None)\n        defaultArg l \"(no location)\"\n\n    let (|Val|_|) e : 't option =\n        match e with\n        | Quotations.Patterns.Value(:? 't as v,_) -> Some v\n        | _ -> None\n\n    let getLocation (q: Expr) =\n        q.CustomAttributes |> Seq.tryPick (function\n            | P.NewTuple [ Val \"DebugRange\";\n                           P.NewTuple [ Val (file: string)\n                                        Val (startLine: int)\n                                        Val (startCol: int)\n                                        Val (endLine: int)\n                                        Val (endCol: int) ] ] ->\n                ({\n                    FileName = System.IO.Path.GetFileName(file)\n                    Start = (startLine, startCol)\n                    End = (endLine, endCol)\n                } : WebSharper.Core.AST.SourcePos)\n                |> Some\n            | _ -> None)\n\n    let rec findArgs (env: Set<string>) (setArg: string -> obj -> unit) (q: Expr) =\n        match q with\n        | P.ValueWithName (v, _, n) when not (env.Contains n) -> setArg n v\n        | P.AddressOf q\n        | P.Coerce (q, _)\n        | P.FieldGet (Some q, _)\n        | P.QuoteRaw q\n        | P.QuoteTyped q\n        | P.VarSet (_, q)\n        | P.WithValue (_, _, q)\n        | P.TupleGet (q, _)\n        | P.TypeTest (q, _)\n        | P.UnionCaseTest (q, _)\n            -> findArgs env setArg q\n        | P.AddressSet (q1, q2)\n        | P.Application (q1, q2)\n        | P.Sequential (q1, q2)\n        | P.TryFinally (q1, q2)\n        | P.WhileLoop (q1, q2)\n            -> findArgs env setArg q1; findArgs env setArg q2\n        | P.PropertyGet (q, _, qs)\n        | P.Call (q, _, qs) ->\n            Option.iter (findArgs env setArg) q\n            List.iter (findArgs env setArg) qs\n        | P.FieldSet (q1, _, q2) ->\n            Option.iter (findArgs env setArg) q1; findArgs env setArg q2\n        | P.ForIntegerRangeLoop (v, q1, q2, q3) ->\n            findArgs env setArg q1\n            findArgs env setArg q2\n            findArgs (Set.add v.Name env) setArg q3\n        | P.IfThenElse (q1, q2, q3)\n            -> findArgs env setArg q1; findArgs env setArg q2; findArgs env setArg q3\n        | P.Lambda (v, q) ->\n            findArgs (Set.add v.Name env) setArg q\n        | P.Let (v, q1, q2) ->\n            findArgs env setArg q1\n            findArgs (Set.add v.Name env) setArg q2\n        | P.LetRecursive (vqs, q) ->\n            let vs, qs = List.unzip vqs\n            let env = (env, vs) ||> List.fold (fun env v -> Set.add v.Name env)\n            List.iter (findArgs env setArg) qs\n            findArgs env setArg q\n        | P.NewObject (_, qs)\n        | P.NewRecord (_, qs)\n        | P.NewTuple qs\n        | P.NewUnionCase (_, qs)\n        | P.NewArray (_, qs) ->\n            List.iter (findArgs env setArg) qs\n        | P.NewDelegate (_, vs, q) ->\n            let env = (env, vs) ||> List.fold (fun env v -> Set.add v.Name env)\n            findArgs env setArg q\n        | P.PropertySet (q1, _, qs, q2) ->\n            Option.iter (findArgs env setArg) q1\n            List.iter (findArgs env setArg) qs\n            findArgs env setArg q2\n        | P.TryWith (q, v1, q1, v2, q2) ->\n            findArgs env setArg q\n            findArgs (Set.add v1.Name env) setArg q1\n            findArgs (Set.add v2.Name env) setArg q2\n        | _ -> ()\n    \n    let internal compileClientSide (meta: M.Info) (reqs: list<M.Node>) (q: Expr) : (obj[] * _) =\n        let rec compile (reqs: list<M.Node>) (q: Expr) =\n            match getLocation q with\n            | Some p ->\n                match meta.Quotations.TryGetValue(p) with\n                | false, _ ->\n                    let ex =\n                        meta.Quotations.Keys\n                        |> Seq.map (sprintf \"  %O\")\n                        |> String.concat \"\\n\"\n                    failwithf \"Failed to find compiled quotation at position %O\\nExisting ones:\\n%s\" p ex\n                | true, (declType, meth, argNames) ->\n                    match meta.Classes.TryGetValue declType with\n                    | false, _ -> failwithf \"Error in ClientSide: Couldn't find JavaScript address for method %s.%s\" declType.Value.FullName meth.Value.MethodName\n                    | true, c ->\n                        let argIndices = Map (argNames |> List.mapi (fun i x -> x, i))\n                        let args = Array.create argNames.Length null\n                        let reqs = ref (M.MethodNode (declType, meth) :: M.TypeNode declType :: reqs)\n                        let setArg (name: string) (value: obj) =\n                            let i = argIndices.[name]\n                            if isNull args.[i] then\n                                args.[i] <-\n                                    match value with\n                                    | :? Expr as q ->\n                                        failwith \"Error in ClientSide: Spliced expressions are not allowed in InlineControl\"\n                                    | value ->\n                                        let typ = value.GetType ()\n                                        reqs := M.TypeNode (WebSharper.Core.AST.Reflection.ReadTypeDefinition typ) :: !reqs\n                                        value\n                        if not (List.isEmpty argNames) then\n                            findArgs Set.empty setArg q\n                        args, !reqs\n            | None -> failwithf \"Failed to find location of quotation: %A\" q\n        compile reqs q \n\n    type private FSV = Reflection.FSharpValue\n\n    let internal compileClientSideFallback (elt: Expr) = \n        let declType, meth, args, fReqs, subs =\n            let elt =\n                match elt with\n                | Coerce (e, _) -> e\n                | e -> e\n            let rec get subs expr =\n                match expr with\n                | PropertyGet(None, p, args) ->\n                    let m = p.GetGetMethod(true)\n                    let dt = R.ReadTypeDefinition p.DeclaringType\n                    let meth = R.ReadMethod m\n                    dt, meth, args, [M.MethodNode (dt, meth)], subs\n                | Call(None, m, args) ->\n                    let dt = R.ReadTypeDefinition m.DeclaringType\n                    let meth = R.ReadMethod m\n                    dt, meth, args, [M.MethodNode (dt, meth)], subs\n                | Let(var, value, body) ->\n                    get (subs |> Map.add var value) body\n                | e -> failwithf \"Wrong format for InlineControl at %s: expected global value or function access, got: %A\" (getLocation' elt) e\n            get Map.empty elt\n        let args, argReqs =\n            args\n            |> List.mapi (fun i value ->\n                let rec get expr =\n                    match expr with\n                    | Value (v, t) ->\n                        let v = match v with null -> WebSharper.Core.Json.Internal.MakeTypedNull t | _ -> v\n                        v, M.TypeNode (R.ReadTypeDefinition t)\n                    | TupleGet(v, i) ->\n                        let v, n = get v\n                        FSV.GetTupleField(v, i), n\n                    | Var v when subs.ContainsKey v ->\n                        get subs.[v]   \n                    | _ -> failwithf \"Wrong format for InlineControl at %s: argument #%i is not a literal or a local variable\" (getLocation' elt) (i+1)\n                get value\n            )\n            |> List.unzip\n        let args = Array.ofList args\n        args, declType, meth, fReqs @ argReqs\n\nopen ClientSideInternals\n\n/// Implements a web control based on a quotation-wrapped top-level body.\n/// Use the function ClientSide or ctx.ClientSide to create an InlineControl.\n[<CompiledName \"FSharpInlineControl\">]\ntype InlineControl<'T when 'T :> IControlBody>(elt: Expr<'T>) =\n    inherit Control()\n\n    [<System.NonSerialized>]\n    let elt = elt\n\n    let mutable args = [||]\n    let mutable funcName = [||]\n\n    [<JavaScript>]\n    override this.Body =\n        let f = Array.fold (?) JS.Window funcName\n        As<Function>(f).ApplyUnsafe(null, args) :?> _\n\n    interface IRequiresResources with\n        member this.Requires(meta) =\n            let declType, meth, reqs =\n                match getLocation elt with\n                | None -> failwith \"Failed to find location of quotation\"\n                | Some p ->\n                    match meta.Quotations.TryGetValue p with\n                    | true, (ty, m, _) ->\n                        let argVals, deps = compileClientSide meta [] elt\n                        args <- argVals\n                        ty, m, deps\n                    | false, _ ->\n                        let argVals, ty, m, deps = compileClientSideFallback elt\n                        args <- argVals\n                        ty, m, deps\n\n            // set funcName\n            let fail() =\n                failwithf \"Error in InlineControl at %s: Couldn't find translation of method %s.%s. The method or type should have JavaScript attribute or a proxy, and the assembly needs to be compiled with WsFsc.exe\" \n                    (getLocation' elt) declType.Value.FullName meth.Value.MethodName\n            match meta.Classes.TryFind declType with\n            | None -> fail()\n            | Some cls ->\n                match cls.Methods.TryFind meth with\n                | Some (M.Static a, _, _) ->\n                    funcName <- Array.ofList (List.rev a.Value)\n                | Some _ ->\n                    failwithf \"Error in InlineControl at %s: Method %s.%s must be static and not inlined\"\n                        (getLocation' elt) declType.Value.FullName meth.Value.MethodName\n                | None -> fail()\n\n            this.GetBodyNode() :: reqs |> Seq.ofList\n\n        member this.Encode(meta, json) =\n            [this.ID, json.GetEncoder(this.GetType()).Encode this]\n\n\nopen System\nopen System.Reflection\nopen System.Linq.Expressions\n\n// TODO: test in arguments: needs .NET 4.5\n// open System.Runtime.CompilerServices\n//[<CallerFilePath; Optional>] sourceFilePath \n//[<CallerLineNumber; Optional>] sourceLineNumber\n[<CompiledName \"InlineControl\">]\ntype CSharpInlineControl(elt: System.Linq.Expressions.Expression<Func<IControlBody>>) =\n    inherit Control()\n\n    [<System.NonSerialized>]\n    let elt = elt\n\n    static let ctrlReq = M.TypeNode (R.ReadTypeDefinition typeof<InlineControl<IControlBody>>)\n\n    [<System.NonSerialized>]\n    let bodyAndReqs =\n        let reduce (e: Expression) = if e.CanReduce then e.Reduce() else e\n        let declType, meth, args, fReqs =\n            match reduce elt.Body with\n            | :? MemberExpression as e ->\n                match e.Member with\n                | :? PropertyInfo as p ->\n                    let m = p.GetGetMethod(true)\n                    let dt = R.ReadTypeDefinition p.DeclaringType\n                    let meth = R.ReadMethod m\n                    dt, meth, [], [M.MethodNode (dt, meth)]\n                | _ -> failwith \"member must be a property\"\n            | :? MethodCallExpression as e -> \n                let m = e.Method\n                let dt = R.ReadTypeDefinition m.DeclaringType\n                let meth = R.ReadMethod m\n                dt, meth, e.Arguments |> List.ofSeq, [M.MethodNode (dt, meth)]\n            | e -> failwithf \"Wrong format for InlineControl: expected global value or function access, got: %A\"  e\n        let args, argReqs =\n            args\n            |> List.mapi (fun i a -> \n                let rec get needType (a: Expression) =\n                    match reduce a with\n                    | :? ConstantExpression as e ->\n                        let v = match e.Value with null -> WebSharper.Core.Json.Internal.MakeTypedNull e.Type | _ -> e.Value\n                        v, if needType then M.TypeNode (R.ReadTypeDefinition e.Type) else M.EntryPointNode\n                    | :? MemberExpression as e ->\n                        let o = \n                            match e.Expression with\n                            | null -> null\n                            | ee -> fst (get false ee)\n                        match e.Member with\n                        | :? FieldInfo as f ->\n                            f.GetValue(o), if needType then M.TypeNode (R.ReadTypeDefinition f.FieldType) else M.EntryPointNode\n                        | :? PropertyInfo as p ->\n                            if p.GetIndexParameters().Length > 0 then\n                                failwithf \"Wrong format for InlineControl in argument #%i, indexed property not allowed\" (i+1)\n                            p.GetValue(o, null), if needType then M.TypeNode (R.ReadTypeDefinition p.PropertyType) else M.EntryPointNode\n                        | m -> failwithf \"Wrong format for InlineControl in argument #%i, member access not allowed: %s\" (i+1) (m.GetType().Name)\n                    | a -> failwithf \"Wrong format for InlineControl in argument #%i, expression type: %s\" (i+1) (a.GetType().Name)\n                get true a\n            )\n            |> List.unzip\n        let args = Array.ofList args\n        let reqs = ctrlReq :: fReqs @ argReqs\n        args, (declType, meth, reqs)\n\n    let args = fst bodyAndReqs\n    let mutable funcName = [||]\n\n    [<JavaScript>]\n    override this.Body =\n        let f = Array.fold (?) JS.Window funcName\n        As<Function>(f).ApplyUnsafe(null, args) :?> _\n\n    interface IRequiresResources with\n        member this.Encode(meta, json) =\n            if funcName.Length = 0 then\n                let declType, meth, reqs = snd bodyAndReqs\n                let fail() =\n                    failwithf \"Error in InlineControl: Couldn't find translation of method %s.%s. The method or type should have JavaScript attribute or a proxy, and the project file needs to include WebSharper.CSharp.targets\" \n                        declType.Value.FullName meth.Value.MethodName\n                match meta.Classes.TryFind declType with\n                | None -> fail()\n                | Some cls ->\n                    match cls.Methods.TryFind meth with\n                    | Some (M.Static a, _, _) ->\n                        funcName <- Array.ofList (List.rev a.Value)\n                    | Some _ -> \n                        failwithf \"Error in InlineControl: Method %s.%s must be static and not inlined\"\n                            declType.Value.FullName meth.Value.MethodName\n                    | None -> fail()\n            [this.ID, json.GetEncoder(this.GetType()).Encode this]\n\n        member this.Requires(_) =\n            let _, _, reqs = snd bodyAndReqs \n            this.GetBodyNode() :: reqs |> Seq.ofList\n\nnamespace WebSharper\n\n[<AutoOpen>]\nmodule WebExtensions =\n\n    open Microsoft.FSharp.Quotations\n    open WebSharper.Web\n\n    /// Embed the given client-side control body in a server-side control.\n    /// The client-side control body must be an implicit or explicit quotation expression.\n    /// It can capture local variables, of the same types which are serializable by WebSharper as RPC results.\n    let ClientSide ([<JavaScript; ReflectedDefinition>] e: Expr<#IControlBody>) =\n        new InlineControl<_>(e)\n"],
"names": [],
"mappings": "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"
}
